<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heating System Visualizer</title>
    <style>
        :root {
            --bg-color: #f0f4f8;
            --primary-color: #4a90e2;
            --secondary-color: #50e3c2;
            --accent-color: #f5a623;
            --text-color: #333;
            --border-color: #d0d0d0;
            --block-bg: #ffffff;
            --shadow-color: rgba(0,0,0,0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 20px;
            text-align: center;
            font-size: 1.5em;
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .main-container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        #controls {
            width: 250px;
            padding: 20px;
            background-color: #fff;
            border-right: 1px solid var(--border-color);
            box-shadow: 2px 0 5px var(--shadow-color);
            overflow-y: auto;
            flex-shrink: 0;
        }

        #controls h2 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 10px;
        }

        #controls button {
            display: block;
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 10px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        #controls button:hover {
            background-color: #45c9b0;
        }
        #controls button:active {
            transform: scale(0.98);
        }

        #controls .connect-mode-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #eef;
            border-radius: 4px;
            font-size: 0.9em;
        }

        #workspace-container {
            flex-grow: 1;
            position: relative;
            background-color: var(--bg-color);
            overflow: auto;
            padding: 10px;
        }

        #workspace {
            position: relative;
            width: 2000px;
            height: 1500px;
            background-image:
                linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            border: 1px solid var(--border-color);
        }

        #connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .block {
            position: absolute;
            min-width: 120px;
            min-height: 60px;
            background-color: var(--block-bg);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 3px 3px 8px var(--shadow-color);
            cursor: grab;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            user-select: none;
            text-align: center;
            font-size: 0.9em;
            box-sizing: border-box;
        }
        .block:active { /* This :active is for general active state, JS handles cursor and z-index for drag */
            cursor: grabbing;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.2);
        }

        .block.selected-for-connection {
            border-color: var(--accent-color);
            box-shadow: 0 0 10px var(--accent-color);
        }

        .heat-pump { border-color: #e74c3c; }
        .heat-pump::before { content: "‚ô®Ô∏è Heat Pump"; display: block; font-weight: bold; margin-bottom: 5px;}

        .buffer { border-color: #3498db; }
        .buffer::before { content: "üîã Buffer"; display: block; font-weight: bold; margin-bottom: 5px;}

        .input-source { border-color: #2ecc71; }
        .input-source::before { content: "‚ö° Input"; display: block; font-weight: bold; margin-bottom: 5px;}

        .text-block {
            background-color: #f9f9f9;
            border-style: dashed;
            min-height: 40px;
            min-width: 100px;
            padding: 15px;
            font-style: italic;
        }
        .text-block::before { content: "üìù Text"; display: block; font-weight: bold; margin-bottom: 5px; font-style: normal;}

        .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: red;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            line-height: 20px;
            text-align: center;
            cursor: pointer;
            display: none;
            z-index: 10;
        }
        .block:hover .delete-btn {
            display: block;
        }

    </style>
</head>
<body>

    <div class="header">
        Heating System Visualizer
    </div>

    <div class="main-container">
        <div id="controls">
            <h2>Components</h2>
            <button onclick="addBlock('heat-pump')">Add Heat Pump</button>
            <button onclick="addBlock('buffer')">Add Buffer Tank</button>
            <button onclick="addBlock('input-source')">Add Input Source</button>
            <button onclick="addBlock('text-block')">Add Text Label</button>

            <h2>Connections</h2>
            <button id="connectButton" onclick="toggleConnectMode()">Start Connecting</button>
            <div id="connectModeInfo" class="connect-mode-info" style="display:none;">
                Click two blocks to connect them.
            </div>

            <h2>Actions</h2>
            <button onclick="clearWorkspace()">Clear Workspace</button>
        </div>

        <div id="workspace-container">
            <div id="workspace">
                <svg id="connection-svg"></svg>
                <!-- Blocks will be added here by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        const workspace = document.getElementById('workspace');
        const svgCanvas = document.getElementById('connection-svg');
        const connectButton = document.getElementById('connectButton');
        const connectModeInfo = document.getElementById('connectModeInfo');
        const workspaceContainer = document.getElementById('workspace-container');

        let blocks = [];
        let connections = [];
        let nextBlockId = 0;
        let nextConnectionId = 0;

        let isDragging = false;
        let dragTarget = null;
        let initialMouseX, initialMouseY;
        let initialElementLeft, initialElementTop;

        let connectMode = false;
        let firstBlockToConnect = null;

        function addBlock(type) {
            const id = `block-${nextBlockId++}`;
            let contentText = type.replace('-', ' ');
            contentText = contentText.charAt(0).toUpperCase() + contentText.slice(1);
            let blockLabel = ""; // To store the user-provided label

            if (type === 'text-block') {
                const userText = prompt("Enter text for the label:", "My Custom Text");
                if (userText === null) return; 
                blockLabel = userText;
            } else {
                 const userEnteredLabel = prompt(`Optional label for ${contentText}:`, "");
                 if (userEnteredLabel !== null && userEnteredLabel.trim() !== "") {
                    blockLabel = userEnteredLabel;
                 }
            }

            const blockDiv = document.createElement('div');
            blockDiv.id = id;
            blockDiv.className = `block ${type}`;
            
            // Create a span for the ::before pseudo-element text (like "Heat Pump")
            // and another for the user-defined label if it exists.
            // The ::before content is now handled by CSS. We just add the custom label.
            if (blockLabel) {
                const labelSpan = document.createElement('span');
                labelSpan.style.whiteSpace = 'pre-wrap'; // Respect newlines in user text
                if (type === 'text-block') {
                    labelSpan.textContent = blockLabel;
                } else {
                    labelSpan.textContent = `(${blockLabel})`; // Put optional labels in parentheses
                }
                blockDiv.appendChild(labelSpan);
            }


            const initialX = 50 + (blocks.length % 6) * 150; 
            const initialY = 50 + Math.floor(blocks.length / 6) * 110;
            blockDiv.style.left = `${initialX}px`;
            blockDiv.style.top = `${initialY}px`;

            const deleteBtn = document.createElement('span');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                deleteBlock(id);
            };
            blockDiv.appendChild(deleteBtn);

            workspace.appendChild(blockDiv);

            const blockData = {
                id: id,
                element: blockDiv,
                type: type,
                x: initialX, 
                y: initialY, 
                connections: []
            };
            blocks.push(blockData);

            makeDraggable(blockDiv); 
            blockDiv.addEventListener('click', () => {
                // Prevent click action if a drag was just completed
                if (new Date().getTime() - (dragTarget?.lastDragTime || 0) < 100) return;
                handleBlockClick(blockData);
            });
        }

        function makeDraggable(element) {
            element.addEventListener('mousedown', (e) => {
                if (e.button !== 0 || e.target.classList.contains('delete-btn')) return;
                
                e.preventDefault(); 
                isDragging = true;
                dragTarget = element;
                dragTarget.lastDragTime = 0; // Initialize for click vs drag detection
                
                initialMouseX = e.clientX;
                initialMouseY = e.clientY;
                initialElementLeft = dragTarget.offsetLeft; 
                initialElementTop = dragTarget.offsetTop;   
                
                dragTarget.style.cursor = 'grabbing';
                dragTarget.style.zIndex = "1000"; 
            });
        }

        document.addEventListener('mousemove', (e) => {
            if (!isDragging || !dragTarget) return;
            e.preventDefault(); 

            const deltaX = e.clientX - initialMouseX;
            const deltaY = e.clientY - initialMouseY;

            let newX = initialElementLeft + deltaX;
            let newY = initialElementTop + deltaY;

            const blockWidth = dragTarget.offsetWidth;
            const blockHeight = dragTarget.offsetHeight;
            const workspaceWidth = workspace.offsetWidth; 
            const workspaceHeight = workspace.offsetHeight;

            newX = Math.max(0, Math.min(newX, workspaceWidth - blockWidth));
            newY = Math.max(0, Math.min(newY, workspaceHeight - blockHeight));

            dragTarget.style.left = `${newX}px`;
            dragTarget.style.top = `${newY}px`;

            const blockData = blocks.find(b => b.id === dragTarget.id);
            if (blockData) {
                blockData.x = newX; 
                blockData.y = newY; 
                updateConnectionsForBlock(blockData.id);
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (isDragging && dragTarget) {
                dragTarget.style.cursor = 'grab';
                dragTarget.style.zIndex = ''; 
                if (dragTarget === e.target || dragTarget.contains(e.target)) { // check if mouseup is on the drag target
                     dragTarget.lastDragTime = new Date().getTime();
                }
                isDragging = false;
                dragTarget = null;
            }
        });
        
        function toggleConnectMode() {
            connectMode = !connectMode;
            const rootStyle = getComputedStyle(document.documentElement); 

            if (connectMode) {
                connectButton.textContent = 'Cancel Connecting';
                connectButton.style.backgroundColor = rootStyle.getPropertyValue('--accent-color').trim() || '#f5a623';
                connectModeInfo.style.display = 'block';
                workspace.style.cursor = 'crosshair';
                if (firstBlockToConnect) {
                    firstBlockToConnect.element.classList.remove('selected-for-connection');
                    firstBlockToConnect = null;
                }
            } else {
                connectButton.textContent = 'Start Connecting';
                // To set to --secondary-color if desired:
                // connectButton.style.backgroundColor = rootStyle.getPropertyValue('--secondary-color').trim() || '#50e3c2';
                // For now, reverting to its default CSS rule:
                connectButton.style.backgroundColor = ''; 
                connectModeInfo.style.display = 'none';
                workspace.style.cursor = 'default';
                if (firstBlockToConnect) {
                    firstBlockToConnect.element.classList.remove('selected-for-connection');
                    firstBlockToConnect = null; // Also clear selection if cancelling mode
                }
            }
        }

        function handleBlockClick(blockData) {
            if (!connectMode) return;
            // The isDragging check inside setTimeout is better to avoid race conditions with mouseup
            setTimeout(() => {
                if (isDragging) return; // Check if a drag operation is active

                if (!firstBlockToConnect) {
                    firstBlockToConnect = blockData;
                    blockData.element.classList.add('selected-for-connection');
                } else {
                    if (firstBlockToConnect.id === blockData.id) {
                        blockData.element.classList.remove('selected-for-connection');
                        firstBlockToConnect = null;
                        return;
                    }
                    createConnection(firstBlockToConnect, blockData);
                    firstBlockToConnect.element.classList.remove('selected-for-connection');
                    blockData.element.classList.remove('selected-for-connection'); 
                    firstBlockToConnect = null; 
                }
            }, 0); 
        }

        function createConnection(block1Data, block2Data) {
            const existingConnection = connections.find(conn =>
                (conn.from === block1Data.id && conn.to === block2Data.id) ||
                (conn.from === block2Data.id && conn.to === block1Data.id)
            );
            if (existingConnection) {
                alert("These blocks are already connected.");
                return;
            }

            const connectionId = `conn-${nextConnectionId++}`;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.id = connectionId;
            const rootStyle = getComputedStyle(document.documentElement);
            line.setAttribute('stroke', rootStyle.getPropertyValue('--text-color').trim() || '#333');
            line.setAttribute('stroke-width', '3');
            line.setAttribute('marker-end', 'url(#arrowhead)');

            svgCanvas.appendChild(line);
            
            const connectionData = {
                id: connectionId,
                from: block1Data.id,
                to: block2Data.id,
                element: line
            };
            connections.push(connectionData);

            block1Data.connections.push(connectionId);
            block2Data.connections.push(connectionId);
            
            updateConnectionLine(connectionData);
        }

        function updateConnectionLine(connectionData) {
            const fromBlock = blocks.find(b => b.id === connectionData.from);
            const toBlock = blocks.find(b => b.id === connectionData.to);

            if (!fromBlock || !toBlock || !fromBlock.element || !toBlock.element) return;

            const line = connectionData.element;

            const x1 = fromBlock.x + fromBlock.element.offsetWidth / 2;
            const y1 = fromBlock.y + fromBlock.element.offsetHeight / 2;
            const x2 = toBlock.x + toBlock.element.offsetWidth / 2;
            const y2 = toBlock.y + toBlock.element.offsetHeight / 2;

            line.setAttribute('x1', String(x1));
            line.setAttribute('y1', String(y1));
            line.setAttribute('x2', String(x2));
            line.setAttribute('y2', String(y2));
        }

        function updateConnectionsForBlock(blockId) {
            connections.forEach(conn => {
                if (conn.from === blockId || conn.to === blockId) {
                    updateConnectionLine(conn);
                }
            });
        }

        function deleteBlock(blockId) {
            const blockIndex = blocks.findIndex(b => b.id === blockId);
            if (blockIndex === -1) return;

            const blockData = blocks[blockIndex];
            
            connections = connections.filter(conn => {
                if (conn.from === blockId || conn.to === blockId) {
                    if (conn.element && conn.element.parentNode === svgCanvas) {
                         svgCanvas.removeChild(conn.element);
                    }
                    // Clean up connection references in the other connected block
                    const otherBlockId = conn.from === blockId ? conn.to : conn.from;
                    const otherBlock = blocks.find(b => b.id === otherBlockId);
                    if (otherBlock) {
                        otherBlock.connections = otherBlock.connections.filter(cId => cId !== conn.id);
                    }
                    return false;
                }
                return true;
            });

            if (blockData.element && blockData.element.parentNode === workspace) {
                workspace.removeChild(blockData.element);
            }
            blocks.splice(blockIndex, 1);
        }

        function clearWorkspace() {
            if (!confirm("Are you sure you want to clear everything?")) return;

            blocks.forEach(block => {
                if (block.element && block.element.parentNode === workspace) {
                    workspace.removeChild(block.element);
                }
            });
            blocks = [];
            nextBlockId = 0; 

            connections.forEach(conn => {
                 if (conn.element && conn.element.parentNode === svgCanvas) {
                    svgCanvas.removeChild(conn.element);
                 }
            });
            connections = [];
            nextConnectionId = 0;

            if (connectMode) {
                toggleConnectMode(); // Reset connect mode UI
            }
        }

        function setupSvgDefs() {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '8'); 
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto-start-reverse'); // Or 'auto'
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
            const rootStyle = getComputedStyle(document.documentElement);
            polygon.setAttribute('fill', rootStyle.getPropertyValue('--text-color').trim() || '#333');
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svgCanvas.appendChild(defs);
        }

        // Initialize
        setupSvgDefs();

    </script>
</body>
</html>