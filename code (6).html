<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual Block Editor Visualizer</title>
    <style>
        /* CSS from previous, with additions for new modal layout */
        :root { /* ... same CSS variables ... */
            --bg-color: #f0f4f8; --primary-color: #4a90e2; --secondary-color: #50e3c2;
            --accent-color: #f5a623; --text-color: #333; --border-color: #d0d0d0;
            --block-bg: #ffffff; --shadow-color: rgba(0,0,0,0.1);
            --grid-line-color: rgba(0,0,0,0.1); --grid-size: 20px;
            --hot-water-color: #e74c3c; --cold-water-color: #3498db;
            --info-signal-color: #2ecc71; --power-color: #9b59b6;
        }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; background-color: var(--bg-color); color: var(--text-color); display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        .header { background-color: var(--primary-color); color: white; padding: 15px 20px; text-align: center; font-size: 1.5em; box-shadow: 0 2px 4px var(--shadow-color); z-index: 100; }
        .main-container { display: flex; flex-grow: 1; overflow: hidden; }
        #controls { width: 300px; padding: 20px; background-color: #fff; border-right: 1px solid var(--border-color); box-shadow: 2px 0 5px var(--shadow-color); overflow-y: auto; flex-shrink: 0; }
        #controls h2, #controls h3 { margin-top: 20px; margin-bottom: 10px; color: var(--primary-color); border-bottom: 2px solid var(--secondary-color); padding-bottom: 8px; }
        #controls h2:first-child { margin-top: 0; }
        #controls button, #controls label.button-like { display: block; width: 100%; padding: 10px 15px; margin-bottom: 8px; background-color: var(--secondary-color); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.95em; text-align: center; transition: background-color 0.3s ease, transform 0.1s ease; box-sizing: border-box; }
        #controls button.special-action, #controls label.button-like.special-action { background-color: var(--accent-color); }
        #controls button:hover, #controls label.button-like:hover { background-color: #45c9b0; }
        #controls button.special-action:hover, #controls label.button-like.special-action:hover { background-color: #d8931e; }
        #controls button:active, #controls label.button-like:active { transform: scale(0.98); }
        #controls input[type="file"] { display: none; }
        #controls .connect-mode-info { margin-top: 15px; padding: 10px; background-color: #eef; border-radius: 4px; font-size: 0.9em; }
        #controls .connect-mode-info strong { color: var(--accent-color); }
        #workspace-container { flex-grow: 1; position: relative; background-color: var(--bg-color); overflow: auto; padding: 10px; }
        #workspace { position: relative; width: 3000px; height: 2500px; background-image: linear-gradient(var(--grid-line-color) 1px, transparent 1px), linear-gradient(90deg, var(--grid-line-color) 1px, transparent 1px); background-size: var(--grid-size) var(--grid-size); border: 1px solid var(--border-color); }
        #connection-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #connection-svg path { fill: none; cursor: pointer; transition: stroke-width 0.1s; }
        #connection-svg path:hover { stroke-width: calc(var(--original-stroke-width, 3px) + 2px); }
        .line-handle { fill: var(--accent-color); stroke: white; stroke-width: 1.5px; cursor: move; r: 7px; transition: r 0.1s; }
        .line-handle:hover { r: 9px; }
        .block { position: absolute; background-color: var(--block-bg); border: 2px solid var(--border-color); border-radius: 8px; box-shadow: 3px 3px 8px var(--shadow-color); cursor: grab; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 10px; user-select: none; text-align: center; font-size: 0.9em; box-sizing: border-box; transition: left 0.1s ease-out, top 0.1s ease-out; }
        .block:active { cursor: grabbing; box-shadow: 5px 5px 15px rgba(0,0,0,0.2); }
        .heat-pump { border-left: 5px solid var(--hot-water-color); } .buffer { border-left: 5px solid var(--primary-color); } .input-source { border-left: 5px solid #f39c12; } .heat-user { border-left: 5px solid var(--cold-water-color); } .sensor { border-left: 5px solid var(--info-signal-color); } .power-source { border-left: 5px solid var(--power-color); } .custom-block { border-left: 5px solid var(--accent-color); } .text-block { background-color: #f9f9f9; border: 2px dashed var(--border-color); font-style: italic; }
        .block-title { font-weight: bold; margin-bottom: 8px; font-size: 1em; } .block-label { font-size: 0.85em; color: #555; white-space: pre-wrap; margin-top: 5px; }
        .delete-btn { position: absolute; top: -10px; right: -10px; background-color: #d9534f; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; font-size: 14px; line-height: 24px; text-align: center; cursor: pointer; display: none; z-index: 1050; }
        .block:hover .delete-btn { display: block; }
        .port { position: absolute; width: 16px; height: 16px; border: 1px solid #555; border-radius: 50%; cursor: pointer; box-sizing: border-box; z-index: 1010; transition: transform 0.2s ease, box-shadow 0.2s ease; }
        .port:hover { transform: scale(1.3); box-shadow: 0 0 5px var(--accent-color); }
        .port.selected-for-connection { border-width: 3px; border-color: var(--accent-color) !important; transform: scale(1.4); }
        .port.hot-water { background-color: var(--hot-water-color); } .port.cold-water { background-color: var(--cold-water-color); } .port.data-signal { background-color: var(--info-signal-color); } .port.power { background-color: var(--power-color); }
        .port-label-tip { visibility: hidden; width: max-content; background-color: #333; color: #fff; text-align: center; border-radius: 4px; padding: 5px 8px; position: absolute; z-index: 1060; bottom: 125%; left: 50%; transform: translateX(-50%); opacity: 0; transition: opacity 0.3s; font-size: 0.8em; }
        .port:hover .port-label-tip { visibility: visible; opacity: 1; }
        
        /* Modal Styles */
        .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); align-items: flex-start; /* Align to top for more space */ justify-content: center; padding-top: 5vh; /* Add some top padding */ }
        .modal-content { background-color: #fefefe; margin: auto; padding: 20px; border: 1px solid #888; border-radius: 8px; width: 95%; max-width: 1200px; /* Wider modal */ box-shadow: 0 5px 15px rgba(0,0,0,0.3); display: flex; flex-direction: column; max-height: 90vh; /* Limit height */ }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-shrink: 0; }
        .modal-header h2 { margin: 0; color: var(--primary-color); }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; }
        
        .modal-body { display: flex; flex-grow: 1; gap: 20px; overflow: hidden; /* Important for scrolling within panes */ }
        .editor-pane { flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 4px; overflow-y: auto; /* Allow scrolling within each pane */ }
        .editor-pane h3 { margin-top: 0; color: var(--primary-color); font-size: 1.1em; border-bottom: 1px solid var(--secondary-color); padding-bottom: 5px;}
        
        #blockDefinitionText { width: 100%; min-height: 300px; height: calc(100% - 40px); /* Adjust based on h3 height */ font-family: monospace; font-size: 0.9em; border: 1px solid var(--border-color); resize: vertical; box-sizing: border-box; padding: 8px; }
        #blockPreviewContainer { display: flex; align-items: center; justify-content: center; background-color: #f9f9f9; min-height: 200px; }
        #blockPreviewSvg { border: 1px dashed var(--border-color); background-color: white; }
        .json-error-message { color: red; font-size: 0.85em; margin-top: 5px; }

        .form-group { margin-bottom: 12px; } .form-group label { display: block; margin-bottom: 4px; font-weight: bold; font-size: 0.9em; }
        .form-group input[type="text"], .form-group input[type="number"], .form-group select { width: calc(100% - 18px); padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; box-sizing: border-box; font-size: 0.9em; }
        .port-editor-row { display: flex; gap: 8px; align-items: center; padding: 8px; border: 1px solid #eee; border-radius: 4px; margin-bottom: 8px; }
        .port-editor-row input, .port-editor-row select { flex-grow: 1; min-width: 70px; }
        .port-editor-row button { padding: 4px 8px; font-size: 0.8em; background-color: #e74c3c; }
        #customPortsContainer .form-group { flex-basis: 22%; }
        .modal-footer { margin-top: 20px; text-align: right; flex-shrink: 0; }
    </style>
</head>
<body>
    <div class="header">Dual Block Editor Visualizer</div>
    <div class="main-container">
        <div id="controls">
            <h2>Standard Components</h2>
            <button onclick="addBlock('heat-pump')">Add Heat Pump</button>
            <button onclick="addBlock('buffer')">Add Buffer Tank</button>
            <button onclick="addBlock('input-source')">Add Input</button>
            <button onclick="addBlock('heat-user')">Add Heat User</button>
            <button onclick="addBlock('sensor')">Add Sensor</button>
            <button onclick="addBlock('power-source')">Add Power Source</button>
            <button onclick="addBlock('text-block')">Add Text Label</button>
            <h3>Custom Components</h3>
            <button id="openBlockEditorBtn" class="special-action" onclick="openBlockEditor()">Create Custom Block</button>
            <div id="customBlockButtonsContainer"></div>
            <h2>Connections</h2>
            <button id="connectButton" onclick="toggleConnectMode()">Connect Ports</button>
            <button id="editLineButton" onclick="toggleLineEditMode()">Edit Lines</button>
            <div id="connectModeInfo" class="connect-mode-info" style="display:none;">Click a <strong>port</strong>, then a <strong>compatible port</strong>.</div>
            <div id="lineEditModeInfo" class="connect-mode-info" style="display:none;">Click a line to select. Drag orange handles to reshape.</div>
            <h2>File</h2>
            <button onclick="saveLayout()">Save Layout</button>
            <label for="loadLayoutInput" class="button-like">Load Layout</label>
            <input type="file" id="loadLayoutInput" accept=".json" onchange="loadLayout(event)">
            <h2>Actions</h2>
            <button onclick="clearWorkspace()">Clear Workspace</button>
        </div>
        <div id="workspace-container">
            <div id="workspace"><svg id="connection-svg"></svg></div>
        </div>
    </div>

    <div id="blockEditorModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Create/Edit Custom Block</h2>
                <span class="close-button" onclick="closeBlockEditor()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="editor-pane" id="visualEditorPane">
                    <h3>Visual Editor</h3>
                    <div class="form-group">
                        <label for="customBlockTitleInput">Block Title:</label>
                        <input type="text" id="customBlockTitleInput" oninput="syncVisualToCurrentDef()">
                    </div>
                    <div class="form-group">
                        <label for="customBlockTypeIDInput">Block Type ID (unique):</label>
                        <input type="text" id="customBlockTypeIDInput" oninput="syncVisualToCurrentDef()">
                    </div>
                    <div class="form-group">
                        <label for="customBlockWidthInput">Width (grid units):</label>
                        <input type="number" id="customBlockWidthInput" value="8" min="1" step="1" oninput="syncVisualToCurrentDef()">
                    </div>
                    <div class="form-group">
                        <label for="customBlockHeightInput">Height (grid units):</label>
                        <input type="number" id="customBlockHeightInput" value="5" min="1" step="1" oninput="syncVisualToCurrentDef()">
                    </div>
                    <h4>Ports:</h4>
                    <div id="customPortsContainer"></div>
                    <button onclick="addPortToEditorForm()" style="margin-top:10px; background-color: var(--primary-color);">Add Port to Form</button>
                </div>
                <div class="editor-pane" id="textEditorPane">
                    <h3>Text (JSON) Editor</h3>
                    <textarea id="blockDefinitionText" oninput="syncTextToCurrentDef()" placeholder='{ "title": "My Block", "width": 8, "height": 5, "ports": [ { "id": "p1", "label": "In", "type": "data-signal", "side": "left", "align": 0 } ] }'></textarea>
                    <div id="jsonErrorDisplay" class="json-error-message"></div>
                </div>
                <div class="editor-pane" id="previewPane">
                    <h3>Live Preview</h3>
                    <div id="blockPreviewContainer">
                        <svg id="blockPreviewSvg"></svg>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                 <button onclick="saveCustomBlockFromEditor()" style="background-color: var(--info-signal-color); padding:10px 20px;">Save Custom Block</button>
            </div>
        </div>
    </div>

    <script>
        // --- Global Constants & Variables (GRID_SIZE, workspace, svgCanvas, etc.) ---
        const GRID_SIZE = 20;
        document.documentElement.style.setProperty('--grid-size', `${GRID_SIZE}px`);
        const workspace = document.getElementById('workspace'); /* ... other global DOM elements ... */
        const svgCanvas = document.getElementById('connection-svg');
        const connectButton = document.getElementById('connectButton');
        const editLineButton = document.getElementById('editLineButton');
        const connectModeInfo = document.getElementById('connectModeInfo');
        const lineEditModeInfo = document.getElementById('lineEditModeInfo');
        const workspaceContainer = document.getElementById('workspace-container');
        
        const blockEditorModal = document.getElementById('blockEditorModal');
        const visualEditorPane = document.getElementById('visualEditorPane'); // For attaching event listeners to inputs
        const customBlockTitleInput = document.getElementById('customBlockTitleInput');
        const customBlockTypeIDInput = document.getElementById('customBlockTypeIDInput');
        const customBlockWidthInput = document.getElementById('customBlockWidthInput');
        const customBlockHeightInput = document.getElementById('customBlockHeightInput');
        const customPortsContainer = document.getElementById('customPortsContainer');
        const blockDefinitionText = document.getElementById('blockDefinitionText');
        const jsonErrorDisplay = document.getElementById('jsonErrorDisplay');
        const blockPreviewSvg = document.getElementById('blockPreviewSvg');
        const customBlockButtonsContainer = document.getElementById('customBlockButtonsContainer');

        let blocks = []; let connections = [];
        let nextBlockId = 0; let nextConnectionId = 0;
        let isDragging = false; let dragTarget = null;
        let initialMouseX, initialMouseY, initialElementLeft, initialElementTop;
        let connectMode = false; let lineEditMode = false;
        let firstPortToConnect = null; let selectedConnection = null; let draggingHandle = null;

        let currentEditingBlockDef = {}; // Holds the block definition being edited
        let isUpdatingFromCode = false; // Flag to prevent infinite loops in sync

        const PREDEFINED_BLOCK_DEFINITIONS = { /* ... same as before ... */
            'heat-pump': { title: "â™¨ï¸ Heat Pump", width: 8, height: 5, ports: [ { id: 'hw_out', label: 'Hot Out', type: 'hot-water', side: 'right', align: 1 }, { id: 'cw_in', label: 'Cold In', type: 'cold-water', side: 'right', align: 3 }, { id: 'power_in', label: 'Power In', type: 'power', side: 'bottom', align: 3 }, { id: 'signal_in', label: 'Control In', type: 'data-signal', side: 'top', align: 3 }, ] },
            'buffer': { title: "ðŸ”‹ Buffer Tank", width: 6, height: 8, ports: [ { id: 'hw_in_top', label: 'Hot In', type: 'hot-water', side: 'left', align: 1 }, { id: 'hw_out_top', label: 'Hot Out', type: 'hot-water', side: 'right', align: 1 }, { id: 'cw_in_bottom', label: 'Cold In', type: 'cold-water', side: 'left', align: 6 }, { id: 'cw_out_bottom', label: 'Cold Out', type: 'cold-water', side: 'right', align: 6 }, ] },
            'input-source': { title: "âš¡ Input Source", width: 6, height: 3, ports: [ { id: 'hw_out', label: 'Hot Out', type: 'hot-water', side: 'right', align: 1 } ] },
            'heat-user': { title: "ðŸ”¥ Heat User", width: 7, height: 4, ports: [ { id: 'hw_in', label: 'Hot In', type: 'hot-water', side: 'left', align: 0 }, { id: 'cw_out', label: 'Cold Out', type: 'cold-water', side: 'left', align: 2 }, { id: 'power_in', label: 'Power In', type: 'power', side: 'bottom', align: 3 }, ] },
            'sensor': { title: "ðŸŒ¡ï¸ Sensor", width: 5, height: 3, ports: [ { id: 'data_out', label: 'Data Out', type: 'data-signal', side: 'right', align: 1 } ] },
            'power-source': { title: "ðŸ’¡ Power Source", width: 6, height: 3, ports: [ { id: 'power_out', label: 'Power Out', type: 'power', side: 'right', align: 1 } ] },
            'text-block': { title: "ðŸ“ Text Label", width: 6, height: 2, ports: [] }
        };
        let userDefinedBlockDefinitions = {};
        function getBlockDefinition(type) { return PREDEFINED_BLOCK_DEFINITIONS[type] || userDefinedBlockDefinitions[type]; }

        // --- Block Editor: Dual Syncing Logic ---
        function openBlockEditor() {
            blockEditorModal.style.display = "flex";
            // Initialize currentEditingBlockDef with defaults or an empty structure
            currentEditingBlockDef = { title: "", typeId: "", width: 8, height: 5, ports: [] };
            syncCurrentDefToVisualForm();
            syncCurrentDefToTextEditor(); // This will also trigger preview update
            updateJsonError(""); // Clear any old errors
        }
        function closeBlockEditor() { blockEditorModal.style.display = "none"; }

        function syncVisualToCurrentDef() { // Called oninput from visual form fields
            if (isUpdatingFromCode) return;
            currentEditingBlockDef.title = customBlockTitleInput.value.trim();
            currentEditingBlockDef.typeId = customBlockTypeIDInput.value.trim().replace(/\s+/g, '_').toLowerCase();
            currentEditingBlockDef.width = parseInt(customBlockWidthInput.value) || 8;
            currentEditingBlockDef.height = parseInt(customBlockHeightInput.value) || 5;
            currentEditingBlockDef.ports = [];
            customPortsContainer.querySelectorAll('.port-editor-row').forEach((row, index) => {
                const label = row.querySelector('.port-label-input').value.trim();
                const type = row.querySelector('.port-type-select').value;
                const side = row.querySelector('.port-side-select').value;
                const align = parseInt(row.querySelector('.port-align-input').value);
                if (label && !isNaN(align)) { // Basic validation
                    currentEditingBlockDef.ports.push({ id: `p${index}`, label, type, side, align });
                }
            });
            // Ensure align values are valid after width/height change
            currentEditingBlockDef.ports.forEach(port => {
                let maxAlign = (port.side === 'top' || port.side === 'bottom') ? currentEditingBlockDef.width - 1 : currentEditingBlockDef.height - 1;
                maxAlign = Math.max(0, maxAlign); // Ensure maxAlign is not negative
                port.align = Math.min(Math.max(0, port.align), maxAlign);
            });

            syncCurrentDefToTextEditor(); // Update text editor and preview
        }

        function syncTextToCurrentDef() { // Called oninput from textarea
            if (isUpdatingFromCode) return;
            try {
                const newDef = JSON.parse(blockDefinitionText.value);
                // Basic validation of loaded structure
                if (typeof newDef.title === 'string' && typeof newDef.width === 'number' && typeof newDef.height === 'number' && Array.isArray(newDef.ports)) {
                    currentEditingBlockDef = { // Create a clean object to avoid carrying over old properties
                        title: newDef.title,
                        typeId: customBlockTypeIDInput.value.trim().replace(/\s+/g, '_').toLowerCase(), // Keep Type ID from form for now
                        width: newDef.width,
                        height: newDef.height,
                        ports: newDef.ports.map((p, i) => ({ // Sanitize ports
                            id: p.id || `p${i}`,
                            label: p.label || "",
                            type: p.type || "data-signal",
                            side: p.side || "right",
                            align: parseInt(p.align) || 0
                        }))
                    };
                    syncCurrentDefToVisualForm(); // Update visual form and preview
                    updateJsonError("");
                } else {
                    updateJsonError("Invalid block structure in JSON.");
                }
            } catch (e) {
                updateJsonError(`JSON Parse Error: ${e.message}`);
            }
        }

        function syncCurrentDefToVisualForm() {
            isUpdatingFromCode = true;
            customBlockTitleInput.value = currentEditingBlockDef.title || "";
            customBlockTypeIDInput.value = currentEditingBlockDef.typeId || "";
            customBlockWidthInput.value = currentEditingBlockDef.width || 8;
            customBlockHeightInput.value = currentEditingBlockDef.height || 5;
            customPortsContainer.innerHTML = ""; // Clear and rebuild port rows
            (currentEditingBlockDef.ports || []).forEach(port => {
                addPortToEditorForm(port);
            });
            updateBlockPreview();
            isUpdatingFromCode = false;
        }

        function syncCurrentDefToTextEditor() {
            isUpdatingFromCode = true;
            // Create a definition for JSON without the typeId (as it's separate)
            const defForJson = { 
                title: currentEditingBlockDef.title, 
                width: currentEditingBlockDef.width, 
                height: currentEditingBlockDef.height, 
                ports: currentEditingBlockDef.ports 
            };
            blockDefinitionText.value = JSON.stringify(defForJson, null, 2);
            updateBlockPreview();
            updateJsonError(""); // Clear error if text was updated successfully from visual
            isUpdatingFromCode = false;
        }
        
        function updateJsonError(message) { jsonErrorDisplay.textContent = message; }

        function addPortToEditorForm(portData = null) { // Can take port data to populate
            const portRow = document.createElement('div'); portRow.className = 'port-editor-row';
            portRow.innerHTML = `
                <input type="text" placeholder="Port Label" class="port-label-input" value="${portData?.label || ''}" oninput="syncVisualToCurrentDef()">
                <select class="port-type-select" onchange="syncVisualToCurrentDef()"> ${['hot-water', 'cold-water', 'data-signal', 'power'].map(t => `<option value="${t}" ${portData?.type === t ? 'selected' : ''}>${t.replace('-', ' ')}</option>`).join('')} </select>
                <select class="port-side-select" onchange="syncVisualToCurrentDef(); updateAlignMaxFromVisual(this);"> ${['top', 'bottom', 'left', 'right'].map(s => `<option value="${s}" ${portData?.side === s ? 'selected' : ''}>${s}</option>`).join('')} </select>
                <input type="number" placeholder="Align Index" class="port-align-input" min="0" step="1" value="${portData?.align || 0}" oninput="syncVisualToCurrentDef()">
                <button onclick="this.parentElement.remove(); syncVisualToCurrentDef();">X</button>
            `;
            customPortsContainer.appendChild(portRow);
            updateAlignMaxFromVisual(portRow.querySelector('.port-side-select')); // Set initial max
             if (!portData) syncVisualToCurrentDef(); // If adding a new blank port, update currentDef
        }
        
        // Update align max when side changes in visual editor
        function updateAlignMaxFromVisual(sideSelectElement) {
            const portRow = sideSelectElement.closest('.port-editor-row');
            const alignInput = portRow.querySelector('.port-align-input');
            const side = sideSelectElement.value;
            const blockWidth = parseInt(customBlockWidthInput.value) || 1; // Use current form values
            const blockHeight = parseInt(customBlockHeightInput.value) || 1;
            let maxAlign = (side === 'top' || side === 'bottom') ? blockWidth - 1 : blockHeight - 1;
            maxAlign = Math.max(0, maxAlign); // Ensure non-negative
            alignInput.max = maxAlign;
            if (parseInt(alignInput.value) > maxAlign) alignInput.value = maxAlign;
            if (parseInt(alignInput.value) < 0) alignInput.value = 0;
        }
        // Add event listeners to width/height inputs to update all align max values
        customBlockWidthInput.addEventListener('input', () => { customPortsContainer.querySelectorAll('.port-side-select').forEach(sel => updateAlignMaxFromVisual(sel)); });
        customBlockHeightInput.addEventListener('input', () => { customPortsContainer.querySelectorAll('.port-side-select').forEach(sel => updateAlignMaxFromVisual(sel)); });


        function saveCustomBlockFromEditor() {
            const typeId = currentEditingBlockDef.typeId;
            if (!currentEditingBlockDef.title || !typeId) { alert("Block Title and Type ID are required."); return; }
            if (PREDEFINED_BLOCK_DEFINITIONS[typeId] || (userDefinedBlockDefinitions[typeId] && typeId !== (window._editingExistingBlockId || null) )) { 
                // Allow overwrite if editing existing block, otherwise check for new collision
                alert(`Block Type ID "${typeId}" already exists or is a predefined ID. Choose a unique ID.`); 
                return; 
            }
            if (currentEditingBlockDef.width < 1 || currentEditingBlockDef.height < 1) { alert("Width/Height must be at least 1."); return; }
            // Further validation for ports (e.g., align within bounds)
            currentEditingBlockDef.ports.forEach(port => {
                let maxAlign = (port.side === 'top' || port.side === 'bottom') ? currentEditingBlockDef.width - 1 : currentEditingBlockDef.height - 1;
                maxAlign = Math.max(0,maxAlign);
                if (port.align < 0 || port.align > maxAlign) {
                    alert(`Port "${port.label}" align value ${port.align} is out of bounds (0-${maxAlign}). Please correct in visual or text editor.`);
                    throw new Error("Invalid port align"); // Stop saving
                }
            });


            userDefinedBlockDefinitions[typeId] = { 
                title: currentEditingBlockDef.title, 
                width: currentEditingBlockDef.width, 
                height: currentEditingBlockDef.height, 
                ports: currentEditingBlockDef.ports.map((p,idx) => ({...p, id: p.id || `cp_${idx}`})), // ensure port IDs
                isCustom: true 
            };
            updateCustomBlockButtons(); closeBlockEditor(); alert(`Custom block "${currentEditingBlockDef.title}" saved!`);
            window._editingExistingBlockId = null; // Clear editing state
        }
        
        // --- Live Preview ---
        function updateBlockPreview() {
            blockPreviewSvg.innerHTML = ''; // Clear previous preview
            const def = currentEditingBlockDef;
            if (!def || !def.width || !def.height) return;

            const previewGridSize = 10; // Smaller grid for preview
            const blockWidthPx = def.width * previewGridSize;
            const blockHeightPx = def.height * previewGridSize;
            const padding = 20;

            blockPreviewSvg.setAttribute('width', blockWidthPx + padding * 2);
            blockPreviewSvg.setAttribute('height', blockHeightPx + padding * 2);
            
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('transform', `translate(${padding}, ${padding})`); // Add padding

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', 0); rect.setAttribute('y', 0);
            rect.setAttribute('width', blockWidthPx); rect.setAttribute('height', blockHeightPx);
            rect.setAttribute('fill', 'var(--block-bg)');
            rect.setAttribute('stroke', 'var(--border-color)');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('rx', '4');
            group.appendChild(rect);

            (def.ports || []).forEach(portDef => {
                const portVisualSize = 8; // Smaller ports for preview
                // Use a simplified getPortPixelPositionOnBlock for preview
                const portPos = getPreviewPortPosition(def, portDef, previewGridSize, portVisualSize);
                
                const portCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                portCircle.setAttribute('cx', portPos.displayX);
                portCircle.setAttribute('cy', portPos.displayY);
                portCircle.setAttribute('r', portVisualSize / 2);
                portCircle.setAttribute('fill', `var(--${portDef.type}-color)`);
                portCircle.setAttribute('stroke', '#555');
                portCircle.setAttribute('stroke-width', '0.5');
                group.appendChild(portCircle);
            });
            blockPreviewSvg.appendChild(group);
        }

        function getPreviewPortPosition(blockDef, portDef, gridSize, portVisualSize) {
            const blockWidthPx = blockDef.width * gridSize;
            const blockHeightPx = blockDef.height * gridSize;
            const offset = portVisualSize / 2;
            let displayX, displayY;

            switch (portDef.side) {
                case 'top':    displayX = (portDef.align * gridSize) + (gridSize / 2) - offset; displayY = 0 - offset; break;
                case 'bottom': displayX = (portDef.align * gridSize) + (gridSize / 2) - offset; displayY = blockHeightPx - offset; break;
                case 'left':   displayX = 0 - offset; displayY = (portDef.align * gridSize) + (gridSize / 2) - offset; break;
                case 'right':  displayX = blockWidthPx - offset; displayY = (portDef.align * gridSize) + (gridSize / 2) - offset; break;
                default:       displayX = blockWidthPx / 2 - offset; displayY = blockHeightPx / 2 - offset;
            }
             // Clamp displayX/Y to be within the block bounds for the dot
            displayX = Math.max(-offset, Math.min(displayX, blockWidthPx - offset));
            displayY = Math.max(-offset, Math.min(displayY, blockHeightPx - offset));

            return { displayX, displayY };
        }


        // --- Rest of the application logic (addBlock, makeDraggable, connections, save/load, etc.) ---
        // Minor change: addBlock calls makeDraggable only if not loadedBlockData
        // Minor change: createConnection and others will use this updated userDefinedBlockDefinitions
        // All other functions like snapToGrid, getPortPixelPositionOnBlock (for main workspace), 
        // mouse events, connection logic, save/load etc. remain largely THE SAME as the previous "Grid-Aligned Port Visualizer"
        // Ensure that all these functions correctly use `getBlockDefinition(type)` to fetch definitions.
        function updateCustomBlockButtons() { customBlockButtonsContainer.innerHTML = ""; for (const typeId in userDefinedBlockDefinitions) { const def = userDefinedBlockDefinitions[typeId]; const btn = document.createElement('button'); btn.textContent = `Add ${def.title}`; btn.onclick = () => addBlock(typeId); customBlockButtonsContainer.appendChild(btn); } }
        function getPortPixelPositionOnBlock(blockDef, portDef, portElementSize = 16) { const blockWidthPx = blockDef.width * GRID_SIZE; const blockHeightPx = blockDef.height * GRID_SIZE; const portVisualOffset = portElementSize / 2; const portConnectionOffset = GRID_SIZE / 2; let cx, cy; let displayX, displayY; switch (portDef.side) { case 'top': cx = portDef.align * GRID_SIZE + GRID_SIZE / 2; cy = -portConnectionOffset; displayX = cx - portVisualOffset; displayY = 0 - portVisualOffset; break; case 'bottom': cx = portDef.align * GRID_SIZE + GRID_SIZE / 2; cy = blockHeightPx + portConnectionOffset; displayX = cx - portVisualOffset; displayY = blockHeightPx - portVisualOffset; break; case 'left': cx = -portConnectionOffset; cy = portDef.align * GRID_SIZE + GRID_SIZE / 2; displayX = 0 - portVisualOffset; displayY = cy - portVisualOffset; break; case 'right': cx = blockWidthPx + portConnectionOffset; cy = portDef.align * GRID_SIZE + GRID_SIZE / 2; displayX = blockWidthPx - portVisualOffset; displayY = cy - portVisualOffset; break; default: cx = blockWidthPx / 2; cy = blockHeightPx / 2; displayX = cx - portVisualOffset; displayY = cy - portVisualOffset; } return { x: cx, y: cy, displayX, displayY }; }
        function addBlock(type, loadedBlockData = null) { const definition = getBlockDefinition(type); if (!definition) { console.error("Unknown block type:", type); return null; } const id = loadedBlockData ? loadedBlockData.id : `block-${nextBlockId++}`; let userLabel = loadedBlockData ? loadedBlockData.userLabel : ""; if (!loadedBlockData && type === 'text-block') { userLabel = prompt("Label:", "My Text"); if (userLabel === null) return null; } else if (!loadedBlockData && type !== 'power-source' && !definition.isCustom && (definition.ports || []).length > 0) { const defaultLabel = prompt(`Label for ${definition.title}:`, ""); if (defaultLabel !== null && defaultLabel.trim() !== "") userLabel = defaultLabel; } const blockDiv = document.createElement('div'); blockDiv.id = id; blockDiv.className = `block ${type} ${definition.isCustom ? 'custom-block' : ''}`; blockDiv.style.width = `${definition.width * GRID_SIZE}px`; blockDiv.style.height = `${definition.height * GRID_SIZE}px`; const titleSpan = document.createElement('span'); titleSpan.className = 'block-title'; titleSpan.textContent = definition.title; blockDiv.appendChild(titleSpan); if (userLabel) { const labelSpan = document.createElement('span'); labelSpan.className = 'block-label'; labelSpan.textContent = userLabel; blockDiv.appendChild(labelSpan); } const initialX = loadedBlockData ? loadedBlockData.x : snapToGrid(50 + (blocks.length % 6) * (definition.width + 2) * GRID_SIZE); const initialY = loadedBlockData ? loadedBlockData.y : snapToGrid(50 + Math.floor(blocks.length / 6) * (definition.height + 2) * GRID_SIZE); blockDiv.style.left = `${initialX}px`; blockDiv.style.top = `${initialY}px`; const deleteBtn = document.createElement('span'); deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.onclick = (e) => { e.stopPropagation(); deleteBlock(id); }; blockDiv.appendChild(deleteBtn); workspace.appendChild(blockDiv); const blockData = { id, element: blockDiv, type, definition, x: initialX, y: initialY, ports: [], connections: [], userLabel }; (definition.ports || []).forEach(portDef => { const portId = `${id}_${portDef.id}`; const portElement = document.createElement('div'); portElement.id = portId; portElement.className = `port ${portDef.type}`; const pos = getPortPixelPositionOnBlock(definition, portDef); portElement.style.left = `${pos.displayX}px`; portElement.style.top = `${pos.displayY}px`; const labelTip = document.createElement('span'); labelTip.className = 'port-label-tip'; labelTip.textContent = portDef.label; portElement.appendChild(labelTip); portElement.onclick = (e) => { e.stopPropagation(); handlePortClick(blockData, portDef, portElement); }; blockDiv.appendChild(portElement); blockData.ports.push({ id: portDef.id, fullId: portId, definition: portDef, element: portElement, connectedToCount: 0 }); }); blocks.push(blockData); if (!loadedBlockData) makeDraggable(blockDiv, blockData); else { blockData.element.style.transition = 'none'; makeDraggable(blockDiv, blockData); /* Ensure draggable is added for loaded blocks too */ } return blockData; }
        function makeDraggable(element, blockData) { element.addEventListener('mousedown', (e) => { if (e.button !== 0 || e.target.classList.contains('delete-btn') || e.target.classList.contains('port')) return; e.preventDefault(); isDragging = true; dragTarget = element; dragTarget.lastDragTime = 0; initialMouseX = e.clientX; initialMouseY = e.clientY; initialElementLeft = dragTarget.offsetLeft; initialElementTop = dragTarget.offsetTop; dragTarget.style.cursor = 'grabbing'; dragTarget.style.zIndex = "1000"; dragTarget.style.transition = 'none'; }); }
        document.addEventListener('mousemove', (e) => { if (isDragging && dragTarget) { e.preventDefault(); const deltaX = e.clientX - initialMouseX, deltaY = e.clientY - initialMouseY; let newX = initialElementLeft + deltaX, newY = initialElementTop + deltaY; dragTarget.style.left = `${newX}px`; dragTarget.style.top = `${newY}px`; const blockData = blocks.find(b => b.id === dragTarget.id); if (blockData) { blockData.x = newX; blockData.y = newY; updateConnectionsForBlock(blockData.id); } } else if (draggingHandle) { e.preventDefault(); const { connection, handleIndex } = draggingHandle; const s = getPortAbsoluteConnectionPoint(connection.fromBlockId, connection.fromPortFullId); const workspaceRect = workspace.getBoundingClientRect(); let mouseX = snapToGrid(e.clientX - workspaceRect.left + workspaceContainer.scrollLeft); let mouseY = snapToGrid(e.clientY - workspaceRect.top + workspaceContainer.scrollTop); if (handleIndex === 0) { if (s.side === 'left' || s.side === 'right') { connection.inflectionPoints[0].x = mouseX; connection.inflectionPoints[1].x = mouseX; } else { connection.inflectionPoints[0].y = mouseY; connection.inflectionPoints[1].y = mouseY; } } else if (handleIndex === 1) { if (s.side === 'left' || s.side === 'right') { connection.inflectionPoints[1].y = mouseY; } else { connection.inflectionPoints[1].x = mouseX; } } calculateAndDrawPath(connection, false); updateLineHandles(connection); } });
        document.addEventListener('mouseup', () => { if (isDragging && dragTarget) { dragTarget.style.cursor = 'grab'; dragTarget.style.zIndex = ''; dragTarget.lastDragTime = new Date().getTime(); const blockData = blocks.find(b => b.id === dragTarget.id); if (blockData) { blockData.x = snapToGrid(dragTarget.offsetLeft); blockData.y = snapToGrid(dragTarget.offsetTop); dragTarget.style.left = `${blockData.x}px`; dragTarget.style.top = `${blockData.y}px`; updateConnectionsForBlock(blockData.id); } dragTarget.style.transition = 'left 0.1s ease-out, top 0.1s ease-out'; isDragging = false; dragTarget = null; } if (draggingHandle) { draggingHandle = null; } });
        function toggleConnectMode() { connectMode = !connectMode; if (connectMode) { setLineEditMode(false); connectButton.textContent = 'Cancel Connecting Ports'; connectButton.style.backgroundColor = 'var(--accent-color)'; connectModeInfo.style.display = 'block'; workspace.style.cursor = 'crosshair'; if (firstPortToConnect) { firstPortToConnect.portElement.classList.remove('selected-for-connection'); firstPortToConnect = null; } } else { connectButton.textContent = 'Connect Ports'; connectButton.style.backgroundColor = ''; connectModeInfo.style.display = 'none'; workspace.style.cursor = 'default'; if (firstPortToConnect) { firstPortToConnect.portElement.classList.remove('selected-for-connection'); firstPortToConnect = null; } } }
        function toggleLineEditMode() { setLineEditMode(!lineEditMode); }
        function setLineEditMode(isOn) { lineEditMode = isOn; if (lineEditMode) { if (connectMode) toggleConnectMode(); editLineButton.textContent = "Stop Editing Lines"; editLineButton.style.backgroundColor = 'var(--accent-color)'; lineEditModeInfo.style.display = 'block'; svgCanvas.style.pointerEvents = 'auto'; if(selectedConnection) selectConnection(selectedConnection); } else { editLineButton.textContent = "Edit Lines"; editLineButton.style.backgroundColor = ''; lineEditModeInfo.style.display = 'none'; svgCanvas.style.pointerEvents = 'none'; deselectConnection(); } }
        function arePortsCompatible(p1Def, p2Def) { return p1Def.type === p2Def.type; }
        const ALLOW_MULTIPLE_CONNECTIONS_TO_PORT = true; 
        function handlePortClick(blockData, portDef, portElement) { if (!connectMode || (new Date().getTime() - (dragTarget?.lastDragTime || 0) < 100)) return; const portDataObj = blockData.ports.find(p => p.fullId === portElement.id); if (portDataObj && portDataObj.connectedToCount && !ALLOW_MULTIPLE_CONNECTIONS_TO_PORT) { alert(`Port ${portDef.label} is already connected (single connection mode).`); return; } if (!firstPortToConnect) { firstPortToConnect = { blockData, portDef, portElement }; portElement.classList.add('selected-for-connection'); } else { if (firstPortToConnect.blockData.id === blockData.id && firstPortToConnect.portElement.id === portElement.id ) { firstPortToConnect.portElement.classList.remove('selected-for-connection'); firstPortToConnect = null; return;  } if (firstPortToConnect.blockData.id === blockData.id && !ALLOW_MULTIPLE_CONNECTIONS_TO_PORT) { alert("Cannot connect a block to itself (unless multiple connections to port allowed)."); if (firstPortToConnect.portElement) firstPortToConnect.portElement.classList.remove('selected-for-connection'); firstPortToConnect = null; return; } if (!arePortsCompatible(firstPortToConnect.portDef, portDef)) { alert(`Ports not compatible: ${firstPortToConnect.portDef.type} vs ${portDef.type}.`); return; } const secondPortData = blockData.ports.find(p => p.fullId === portElement.id); if (secondPortData && secondPortData.connectedToCount && !ALLOW_MULTIPLE_CONNECTIONS_TO_PORT) { alert(`Target port ${portDef.label} is already connected (single connection mode).`); return; } createConnection(firstPortToConnect, { blockData, portDef, portElement }); firstPortToConnect.portElement.classList.remove('selected-for-connection'); firstPortToConnect = null; } }
        function getPortAbsoluteConnectionPoint(blockId, portFullId) { const block = blocks.find(b => b.id === blockId); if (!block) return null; const portObj = block.ports.find(p => p.fullId === portFullId); if (!portObj || !portObj.element) return null; const portPosOnBlock = getPortPixelPositionOnBlock(block.definition, portObj.definition); const x = block.x + portPosOnBlock.x; const y = block.y + portPosOnBlock.y; return { x, y, side: portObj.definition.side }; }
        function createConnection(port1Info, port2Info, loadedConnectionData = null) { const connectionId = loadedConnectionData ? loadedConnectionData.id : `conn-${nextConnectionId++}`; const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path'); pathElement.id = connectionId; let strokeColor = 'var(--text-color)', strokeDashArray = "none", strokeWidth = '3'; pathElement.style.setProperty('--original-stroke-width', strokeWidth + 'px'); switch (port1Info.portDef.type) { case 'hot-water': strokeColor = 'var(--hot-water-color)'; break; case 'cold-water': strokeColor = 'var(--cold-water-color)'; break; case 'data-signal': strokeColor = 'var(--info-signal-color)'; strokeDashArray = "5,5"; break; case 'power': strokeColor = 'var(--power-color)'; strokeWidth = '4'; pathElement.style.setProperty('--original-stroke-width', strokeWidth + 'px'); break; } pathElement.setAttribute('stroke', strokeColor); pathElement.setAttribute('stroke-width', strokeWidth); pathElement.setAttribute('stroke-dasharray', strokeDashArray); pathElement.setAttribute('fill', 'none'); if (port1Info.portDef.type !== 'data-signal') pathElement.setAttribute('marker-end', 'url(#arrowhead)'); const connectionData = { id: connectionId, type: port1Info.portDef.type, fromBlockId: port1Info.blockData.id, fromPortFullId: port1Info.portElement.id, toBlockId: port2Info.blockData.id, toPortFullId: port2Info.portElement.id, element: pathElement, inflectionPoints: loadedConnectionData ? loadedConnectionData.inflectionPoints : [], handles: [] }; svgCanvas.appendChild(pathElement); connections.push(connectionData); pathElement.addEventListener('click', (e) => { if (lineEditMode) { e.stopPropagation(); selectConnection(connectionData); } }); port1Info.blockData.connections.push(connectionId); port2Info.blockData.connections.push(connectionId); const p1 = port1Info.blockData.ports.find(p => p.fullId === port1Info.portElement.id); if (p1) p1.connectedToCount = (p1.connectedToCount || 0) + 1; const p2 = port2Info.blockData.ports.find(p => p.fullId === port2Info.portElement.id); if (p2) p2.connectedToCount = (p2.connectedToCount || 0) + 1; calculateAndDrawPath(connectionData, !loadedConnectionData); return connectionData; }
        function calculateInflectionPoints(s, e) { let ip1 = {}, ip2 = {}; if (s.side === 'left' || s.side === 'right') { ip1.x = snapToGrid((s.x + e.x) / 2); ip1.y = s.y; ip2.x = ip1.x; ip2.y = e.y; } else { ip1.x = s.x; ip1.y = snapToGrid((s.y + e.y) / 2); ip2.x = e.x; ip2.y = ip1.y; } return [ip1, ip2]; }
        function pointsToPathString(s, e, inflectionPoints) { const [ip1, ip2] = inflectionPoints; let d = `M ${s.x} ${s.y}`; if (s.side === 'left' || s.side === 'right') { d += ` L ${ip1.x} ${s.y}`; d += ` L ${ip1.x} ${ip2.y}`; d += ` L ${e.x} ${ip2.y}`; } else { d += ` L ${s.x} ${ip1.y}`; d += ` L ${ip2.x} ${ip1.y}`; d += ` L ${ip2.x} ${e.y}`; } d += ` L ${e.x} ${e.y}`; return d; }
        function calculateAndDrawPath(connectionData, initializeIPs = false) { const s = getPortAbsoluteConnectionPoint(connectionData.fromBlockId, connectionData.fromPortFullId); const e = getPortAbsoluteConnectionPoint(connectionData.toBlockId, connectionData.toPortFullId); if (!s || !e) return; if (initializeIPs || !connectionData.inflectionPoints || connectionData.inflectionPoints.length !== 2) { connectionData.inflectionPoints = calculateInflectionPoints(s, e); } const pathString = pointsToPathString(s, e, connectionData.inflectionPoints); connectionData.element.setAttribute('d', pathString); if (selectedConnection && selectedConnection.id === connectionData.id) { updateLineHandles(connectionData); } }
        function updateConnectionsForBlock(blockId) { connections.forEach(conn => { if (conn.fromBlockId === blockId || conn.toBlockId === blockId) calculateAndDrawPath(conn, true); }); }
        function selectConnection(connectionData) { deselectConnection(); selectedConnection = connectionData; selectedConnection.element.style.stroke = 'var(--accent-color)'; selectedConnection.element.style.strokeWidth = `calc(${getComputedStyle(selectedConnection.element).getPropertyValue('--original-stroke-width')} + 3px)`; createLineHandles(selectedConnection); }
        function deselectConnection() { if (selectedConnection) { selectedConnection.element.style.stroke = ''; selectedConnection.element.style.strokeWidth = ''; removeLineHandles(selectedConnection); } selectedConnection = null; }
        function createLineHandles(connection) { removeLineHandles(connection); const [ip1, ip2] = connection.inflectionPoints; const handle1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); handle1.setAttribute('cx', ip1.x); handle1.setAttribute('cy', ip1.y); handle1.setAttribute('class', 'line-handle'); handle1.addEventListener('mousedown', (e) => { e.stopPropagation(); draggingHandle = { connection, handleIndex: 0 }; }); svgCanvas.appendChild(handle1); connection.handles.push(handle1); const handle2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); handle2.setAttribute('cx', ip2.x); handle2.setAttribute('cy', ip2.y); handle2.setAttribute('class', 'line-handle'); handle2.addEventListener('mousedown', (e) => { e.stopPropagation(); draggingHandle = { connection, handleIndex: 1 }; }); svgCanvas.appendChild(handle2); connection.handles.push(handle2); }
        function removeLineHandles(connection) { connection.handles.forEach(h => { if (h.parentNode) h.parentNode.removeChild(h); }); connection.handles = []; }
        function updateLineHandles(connection) { if (selectedConnection && selectedConnection.id === connection.id && lineEditMode) { createLineHandles(connection); } }
        function deleteBlock(blockId) { const blockIndex = blocks.findIndex(b => b.id === blockId); if (blockIndex === -1) return; const blockData = blocks[blockIndex]; if (selectedConnection && (selectedConnection.fromBlockId === blockId || selectedConnection.toBlockId === blockId)) { deselectConnection(); } connections = connections.filter(conn => { if (conn.fromBlockId === blockId || conn.toBlockId === blockId) { if (conn.element && conn.element.parentNode === svgCanvas) svgCanvas.removeChild(conn.element); removeLineHandles(conn); const otherBlockId = conn.fromBlockId === blockId ? conn.toBlockId : conn.fromBlockId; const otherPortFullId = conn.fromBlockId === blockId ? conn.toPortFullId : conn.fromPortFullId; const otherBlock = blocks.find(b => b.id === otherBlockId); if (otherBlock) { const otherPort = otherBlock.ports.find(p => p.fullId === otherPortFullId); if (otherPort) otherPort.connectedToCount = Math.max(0, (otherPort.connectedToCount || 0) - 1); otherBlock.connections = otherBlock.connections.filter(cId => cId !== conn.id); } return false; } return true; }); if (blockData.element && blockData.element.parentNode === workspace) workspace.removeChild(blockData.element); blocks.splice(blockIndex, 1); }
        function clearWorkspace(confirmClear = true) { if (confirmClear && !confirm("Clear workspace?")) return; deselectConnection(); blocks.forEach(block => { if (block.element && block.element.parentNode === workspace) workspace.removeChild(block.element); }); blocks = []; nextBlockId = 0; connections.forEach(conn => { if (conn.element && conn.element.parentNode === svgCanvas) svgCanvas.removeChild(conn.element); removeLineHandles(conn); }); connections = []; nextConnectionId = 0; if (connectMode) toggleConnectMode(); if (lineEditMode) setLineEditMode(false); if (firstPortToConnect) { if(firstPortToConnect.portElement) firstPortToConnect.portElement.classList.remove('selected-for-connection'); firstPortToConnect = null; } userDefinedBlockDefinitions = {}; updateCustomBlockButtons(); }
        function setupSvgDefs() { const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs'); const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker'); marker.setAttribute('id', 'arrowhead'); marker.setAttribute('markerWidth', '10'); marker.setAttribute('markerHeight', '7'); marker.setAttribute('refX', '8'); marker.setAttribute('refY', '3.5'); marker.setAttribute('orient', 'auto'); const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); polygon.setAttribute('points', '0 0, 10 3.5, 0 7'); polygon.setAttribute('fill', 'currentColor'); marker.appendChild(polygon); defs.appendChild(marker); svgCanvas.appendChild(defs); }
        function saveLayout() { const layoutData = { blocks: blocks.map(b => ({ id: b.id, type: b.type, x: b.x, y: b.y, userLabel: b.userLabel || "" })), connections: connections.map(c => ({ id: c.id, type: c.type, fromBlockId: c.fromBlockId, fromPortRelativeId: c.fromPortFullId.split('_').slice(1).join('_'), toBlockId: c.toBlockId, toPortRelativeId: c.toPortFullId.split('_').slice(1).join('_'), inflectionPoints: c.inflectionPoints })), userDefinedBlockDefinitions: userDefinedBlockDefinitions, nextBlockId: nextBlockId, nextConnectionId: nextConnectionId }; const jsonString = JSON.stringify(layoutData, null, 2); const blob = new Blob([jsonString], {type: "application/json"}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = "heating_system_layout.json"; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); alert("Layout saved!"); }
        function loadLayout(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = function(e) { try { const layoutData = JSON.parse(e.target.result); clearWorkspace(false); userDefinedBlockDefinitions = layoutData.userDefinedBlockDefinitions || {}; updateCustomBlockButtons(); nextBlockId = layoutData.nextBlockId || 0; nextConnectionId = layoutData.nextConnectionId || 0; const idMap = {}; (layoutData.blocks || []).forEach(savedBlock => { const newBlockData = addBlock(savedBlock.type, { id: savedBlock.id, x: savedBlock.x, y: savedBlock.y, userLabel: savedBlock.userLabel }); if (newBlockData) { idMap[savedBlock.id] = newBlockData.id; newBlockData.element.style.left = `${savedBlock.x}px`; newBlockData.element.style.top = `${savedBlock.y}px`; }}); (layoutData.connections || []).forEach(savedConn => { const newFromBlockId = idMap[savedConn.fromBlockId]; const newToBlockId = idMap[savedConn.toBlockId]; const fromBlockData = blocks.find(b => b.id === newFromBlockId); const toBlockData = blocks.find(b => b.id === newToBlockId); if (fromBlockData && toBlockData) { const fromPort = fromBlockData.ports.find(p => p.id === savedConn.fromPortRelativeId); const toPort = toBlockData.ports.find(p => p.id === savedConn.toPortRelativeId); if (fromPort && toPort) { createConnection( { blockData: fromBlockData, portDef: fromPort.definition, portElement: fromPort.element }, { blockData: toBlockData, portDef: toPort.definition, portElement: toPort.element }, { id: savedConn.id, inflectionPoints: savedConn.inflectionPoints } ); } else { console.warn("Could not find ports for connection:", savedConn); } } else { console.warn("Could not find blocks for connection:", savedConn); } }); alert("Layout loaded successfully!"); } catch (err) { console.error("Error loading layout:", err); alert("Failed to load layout."); } event.target.value = null; }; reader.readAsText(file); }
        
        setupSvgDefs(); updateCustomBlockButtons();
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape') { if (blockEditorModal.style.display === "flex") closeBlockEditor(); else if (lineEditMode && selectedConnection) deselectConnection(); else if (connectMode && firstPortToConnect) { firstPortToConnect.portElement.classList.remove('selected-for-connection'); firstPortToConnect = null; } } });
        window.onclick = (e) => { if (e.target == blockEditorModal) closeBlockEditor(); else if (lineEditMode && e.target === svgCanvas) { deselectConnection(); } };
    </script>
</body>
</html>
